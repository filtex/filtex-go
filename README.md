# Filtex

The Filtex library is a versatile tool designed to filtering data across various sources like PostgreSQL, MongoDB, and in-memory datasets. This library empowers developers to create complex queries using both JSON and text formats, generating expressions compatible with the target data sources.

It allows to configure your dataset with some options and provides a metadata model to be able to use in UI components and then it accepts the query that is generated by UI and generates query for data sources like Postgres, Mongo etc.

Check the packages for other platforms.
- [filtex-net](https://github.com/filtex/filtex-net)
- [filtex-js](https://github.com/filtex/filtex-js)
- [filtex-ui](https://github.com/filtex/filtex-ui)


## Setup

```shell
go get github.com/filtex/filtex-go
```

## Usage

#### Configure

```go
import "github.com/filtex/filtex-go"
import "github.com/filtex/filtex-go/models"
import "github.com/filtex/filtex-go/options"

// Create new filtex instance with options
fx, err := filtex.New(
    options.NewFieldOption().String().Name("name").Label("Name"),
    options.NewFieldOption().Number().Name("version").Label("Version"),
    options.NewFieldOption().Boolean().Name("status").Label("Status").Lookup("statuses"),
    options.NewLookupOption().Key("statuses").Values([]models.Lookup{
        {"Enabled", true},
        {"Disabled", false},
    }),
)
if err != nil {
    panic(err)
}
```

#### Metadata

```go
// Get metadata model to render components
metadata, err := fx.Metadata()
if err != nil {
    panic(err)
}

println(metadata)
```

#### Expression From Text

```go
// Generate expression from the text input
expression, err := fx.ExpressionFromText("Name Contain Filtex And Status Equal Enabled")
if err != nil {
    panic(err)
}
```

#### Expression From JSON

```go
// Generate expression from the json input
expression, err := fx.ExpressionFromJson(`[
    "And",
    [
        ["Name", "Contain", "Filtex"],
        ["Status", "Equal", "Enabled"]
    ]
]`)
if err != nil {
    panic(err)
}
```

#### Validate From Text

```go
// Validate from the text input
err := fx.ValidateFromText("Name Contain Filtex And Status Equal Enabled")
if err != nil {
    panic(err)
}
```

#### Validate From JSON

```go
// Validate from the json input
err := fx.ValidateFromJson(`[
    "And",
    [
        ["Name", "Contain", "Filtex"],
        ["Status", "Equal", "Enabled"]
    ]
]`)
if err != nil {
    panic(err)
}
```

#### Mongo Filter

```go
import "github.com/filtex/filtex-go/builders/mongo"

// Generate filter from the expression for mongo
mongoFilter, err := mongo.NewMongoFilterBuilder().Build(expression)
if err != nil {
    panic(err)
}

println(mongoFilter)

// Use generated mongo filter
result, err := mongoClient.GetCollection("projects").Find(mongoFilter.Condition)
if err != nil {
    panic(err)
}

println(result)
```

#### Postgres Filter

```go
import "github.com/filtex/filtex-go/builders/postgres"

// Generate filter from the expression for postgres
postgresFilter, err := postgres.NewPostgresFilterBuilder().Build(expression)
if err != nil {
    panic(err)
}

println(postgresFilter)

// Use generated postgres filter
sql := "SELECT * FROM projects WHERE " + postgresFilter.Condition
result, err := postgresClient.Query(sql, postgresFilter.Args)
if err != nil {
    panic(err)
}

println(result)
```

#### Memory Filter

```go
import "github.com/filtex/filtex-go/builders/memory"

// Generate filter from the expression for memory
memoryFilter, err := memory.NewMemoryFilterBuilder().Build(expression)
if err != nil {
    panic(err)
}

// Use generated memory function
result := make([]interface{}, 0)

for _, v := range items {
    if memoryFilter.Fn(v) {
        result = append(result, v)
    }
}

println(result)
```

## License
This library is licensed under the [MIT License](LICENSE).
